import fr.inria.aoste.timesquare.ecl.EclQVToHelper;
 
	
modeltype Ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
//modeltype pivot uses 'http://www.eclipse.org/ocl/3.1.0/Pivot';

	modeltype inMM1 uses 'http://execarduino/';


//modeltype inMM uses 'http://execarduino/';
modeltype QVT uses 'http://www.eclipse.org/QVT/1.0.0/Operational';//http://www.eclipse.org/m2m/qvt/oml/1.0.0/Stdlib';//http://www.eclipse.org/qvt/1.0/ImperativeOCL'; 
modeltype TimeModel uses 'http://fr.inria.aoste.timemodel';

modeltype FeedBack uses 'http://timesquare.inria.fr/feedback';

transformation doarduino_To_CCSL(in inM : inMM1, out ccsl : TimeModel, out feedback : FeedBack);
property theFeedBackSpec		:FeedBack::ActionModel = null;
property seqOfMSE :	Sequence(FeedBack::ModelSpecificEvent)    = Sequence{};

property theCCSLSpec			:TimeModel::CCSLModel::ClockConstraintSystem = null;
property theMainBlock			:TimeModel::CCSLModel::Block				 = null;

property Kernel_Integer 	: TimeModel::BasicType::Type		= null;
property Kernel_Clock_Type 	: TimeModel::BasicType::Type		= null;

property seqOfRelationDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration)    = Sequence{};
property seqOfAbstractEntity :		Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)    = Sequence{};
property seqOfExpressionDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration)    = Sequence{};


query identifyUserRelations() {
	var kernelTypes :  	Sequence(TimeModel::BasicType::Type) := Sequence{};
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::BasicType::Type];

	Kernel_Integer 					:= kernelTypes[name='int']->asSequence()->first();
	Kernel_Clock_Type				:= kernelTypes[name='clock']->asSequence()->first();	
	return;
}


//usefull function :)
	mapping Real::Real2Integer(n: String) :TimeModel::BasicType::IntegerElement {
		name:= n;
		type:= Kernel_Integer;
		value := self.round();

		end{
			theMainBlock.elements += result;
		}
	}

main() {
	identifyUserRelations();
	inM.rootObjects()[inMM1::Project]->asSequence()->first()-> map arduino2CCSL();
	inM.rootObjects()[inMM1::Project]->asSequence()->first()-> map arduino2FeedBack();

	}

			
	mapping inMM1::Project::arduino2CCSL() : TimeModel::CCSLModel::ClockConstraintSystem {
	    theCCSLSpec := result;
	    name := getNameOrUID(self.oclAsType(EObject));
	    theMainBlock :=object TimeModel::CCSLModel::Block{
	    	name := "mainBlock";
	    };
	    subBlock += theMainBlock;
	    result.superBlock := theMainBlock;
		
		var anEmptyBlock :=object TimeModel::CCSLModel::Block{
	    	name := "emptyBlock";
	    };
	    subBlock += anEmptyBlock;
		
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib';
			alias := 'kernel';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib';
			alias := 'CCSL';
			
		}; 
	
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};

		

		////[ Instruction ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instruction.oclAsType(EClass)).oclAsType(Instruction)->map start2Clock();
		////[ Instruction ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instruction.oclAsType(EClass)).oclAsType(Instruction)->map stop2Clock();
		


		

		////[ Sketch ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Sketch.oclAsType(EClass)).oclAsType(Sketch)->map start2Clock();
		////[ Sketch ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Sketch.oclAsType(EClass)).oclAsType(Sketch)->map stop2Clock();
		


		

		////[ Control ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Control.oclAsType(EClass)).oclAsType(Control)->map doEvaluate2Clock();
		////[ Control ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Control.oclAsType(EClass)).oclAsType(Control)->map evaluatedToTrue2Clock();
		////[ Control ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Control.oclAsType(EClass)).oclAsType(Control)->map evaluatedToFalse2Clock();
		


		

		////[ ArduinoCommunicationModule ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ArduinoCommunicationModule.oclAsType(EClass)).oclAsType(ArduinoCommunicationModule)->map send2Clock();
		////[ ArduinoCommunicationModule ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ArduinoCommunicationModule.oclAsType(EClass)).oclAsType(ArduinoCommunicationModule)->map receive2Clock();
		


		

		////[ PushButton ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), PushButton.oclAsType(EClass)).oclAsType(PushButton)->map toggleIt2Clock();
		


		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Sketch.oclAsType(EClass)).oclAsType(Sketch)->map S_nonReentrant12S_nonReentrant();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Sketch.oclAsType(EClass)).oclAsType(Sketch)->map S_startInternalFirst12S_startInternalFirst();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Sketch.oclAsType(EClass)).oclAsType(Sketch)->map S_stopInternalFirst12S_stopInternalFirst();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instruction.oclAsType(EClass)).oclAsType(Instruction)->map I_OrderEnforcement472I_OrderEnforcement();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instruction.oclAsType(EClass)).oclAsType(Instruction)->map I_atomicbutDelayAndControlAndModuleGet372I_atomicbutDelayAndControlAndModuleGet();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Delay.oclAsType(EClass)).oclAsType(Delay)->map D_NonAtomic12D_NonAtomic();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), If.oclAsType(EClass)).oclAsType(If)->map I_nonReentrant12I_nonReentrant();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), If.oclAsType(EClass)).oclAsType(If)->map I_startMeansEvaluate12I_startMeansEvaluate();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), If.oclAsType(EClass)).oclAsType(If)->map I_evaluatingResultsInTrueOrFalse122I_evaluatingResultsInTrueOrFalse();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), If.oclAsType(EClass)).oclAsType(If)->map I_trueExclusifFalse12I_trueExclusifFalse();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), If.oclAsType(EClass)).oclAsType(If)->map I_startInternalofThen12I_startInternalofThen();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), If.oclAsType(EClass)).oclAsType(If)->map I_startInternalofElse102I_startInternalofElse();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), If.oclAsType(EClass)).oclAsType(If)->map I_startInternalofElseEmpty282I_startInternalofElseEmpty();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), If.oclAsType(EClass)).oclAsType(If)->map I_stopInternalFirst342I_stopInternalFirst();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), While.oclAsType(EClass)).oclAsType(While)->map W_startOrFinishLoopMeansEvaluate192W_startOrFinishLoopMeansEvaluate();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), While.oclAsType(EClass)).oclAsType(While)->map W_evaluatingResultsInTrueOrFalse122W_evaluatingResultsInTrueOrFalse();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), While.oclAsType(EClass)).oclAsType(While)->map W_trueExclusifFalse12W_trueExclusifFalse();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), While.oclAsType(EClass)).oclAsType(While)->map W_startInternalFirst12W_startInternalFirst();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), While.oclAsType(EClass)).oclAsType(While)->map W_stopwhenEvaluatedFalse12W_stopwhenEvaluatedFalse();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Repeat.oclAsType(EClass)).oclAsType(Repeat)->map R_startMeansEvaluate192R_startMeansEvaluate();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Repeat.oclAsType(EClass)).oclAsType(Repeat)->map R_evaluatingResultsInTrueOrFalse122R_evaluatingResultsInTrueOrFalse();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Repeat.oclAsType(EClass)).oclAsType(Repeat)->map R_trueExclusifFalse12R_trueExclusifFalse();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Repeat.oclAsType(EClass)).oclAsType(Repeat)->map R_startInternalFirst12R_startInternalFirst();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Repeat.oclAsType(EClass)).oclAsType(Repeat)->map R_stopwhenEvaluatedFalse12R_stopwhenEvaluatedFalse();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ModuleGet.oclAsType(EClass)).oclAsType(ModuleGet)->map waitIfInVariableAssignment272waitIfInVariableAssignment();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ModuleAssignment.oclAsType(EClass)).oclAsType(ModuleAssignment)->map sendAfterAssignement122sendAfterAssignement();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), BluetoothTransceiver.oclAsType(EClass)).oclAsType(BluetoothTransceiver)->map sendBeforeReceive982sendBeforeReceive();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), BluetoothTransceiver.oclAsType(EClass)).oclAsType(BluetoothTransceiver)->map allReceiveTogether132allReceiveTogether();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), VariableAssignment.oclAsType(EClass)).oclAsType(VariableAssignment)->map getDataIfModuleGetCom322getDataIfModuleGetCom();
		
	}





//create the expressions...
	mapping inMM1::If::i_trueOrFalse2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_i_trueOrFalse';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToFalse']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToTrue']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	mapping inMM1::If::i_lastInstructionfromthenOrFalse2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_i_lastInstructionfromthenOrFalse';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.block.instructions->last().oclAsType(EObject))+'_stop']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToFalse']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	mapping inMM1::If::i_lastInstructionfromthenOrElse2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_i_lastInstructionfromthenOrElse';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.block.instructions->last().oclAsType(EObject))+'_stop']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.elseBlock.instructions->last().oclAsType(EObject))+'_stop']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	mapping inMM1::While::w_startOrEndLoop2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_w_startOrEndLoop';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.block.instructions->last().oclAsType(EObject))+'_stop']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	mapping inMM1::While::w_trueOrFalse2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_w_trueOrFalse';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToFalse']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToTrue']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	mapping inMM1::Repeat::r_startOrEndLoop2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_r_startOrEndLoop';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.block.instructions->last().oclAsType(EObject))+'_stop']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	mapping inMM1::Repeat::r_trueOrFalse2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_Union_r_trueOrFalse';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToFalse']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToTrue']->first();
				//	var size : Integer = seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}



	 	mapping inMM1::Instruction::start2Clock() :TimeModel::Clock 
			when { (not ((self).oclIsKindOf(ModuleGet))) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_start';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "execute")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_start';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM1::Instruction::stop2Clock() :TimeModel::Clock 
			when { (not ((self).oclIsKindOf(ModuleGet))) }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_stop';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "finalize")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_stop';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM1::Sketch::start2Clock() :TimeModel::Clock 
			when {  }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_start';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_start';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM1::Sketch::stop2Clock() :TimeModel::Clock 
			when {  }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_stop';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_stop';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM1::Control::doEvaluate2Clock() :TimeModel::Clock 
			when {  }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_doEvaluate';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "evaluate")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_doEvaluate';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM1::Control::evaluatedToTrue2Clock() :TimeModel::Clock 
			when {  }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_evaluatedToTrue';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_evaluatedToTrue';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM1::Control::evaluatedToFalse2Clock() :TimeModel::Clock 
			when {  }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_evaluatedToFalse';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_evaluatedToFalse';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM1::ArduinoCommunicationModule::send2Clock() :TimeModel::Clock 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().allSubobjectsOfKind(ModuleAssignment)->select(ma|(ma).oclAsType(ModuleAssignment).module = self))->size() >0 }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_send';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "push")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_send';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM1::ArduinoCommunicationModule::receive2Clock() :TimeModel::Clock 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().allSubobjectsOfKind(ModuleGet)->select(ma|(ma).oclAsType(ModuleGet).module = self))->size() >0 }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_receive';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_receive';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM1::PushButton::toggleIt2Clock() :TimeModel::Clock 
			when {  }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_toggleIt';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "toggle")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_toggleIt';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		

//relation stuff		
	
		mapping inMM1::Sketch::S_nonReentrant12S_nonReentrant(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Alternates_S_nonReentrant";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_stop']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::Sketch::S_startInternalFirst12S_startInternalFirst(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_S_startInternalFirst";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.block.instructions->first().oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::Sketch::S_stopInternalFirst12S_stopInternalFirst(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_S_stopInternalFirst";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.block.instructions->last().oclAsType(EObject))+'_stop']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_stop']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::Instruction::I_OrderEnforcement472I_OrderEnforcement(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.oclAsType(ecore::EObject).eContainer().oclAsType(Block).instructions->last() <> self) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_I_OrderEnforcement";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
					var indexOfNextInstruction : Integer := self.oclAsType(ecore::EObject).eContainer().oclAsType(Block).instructions->indexOf(self)+1;
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_stop']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(ecore::EObject).eContainer().oclAsType(Block).instructions->at(indexOfNextInstruction).oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::Instruction::I_atomicbutDelayAndControlAndModuleGet372I_atomicbutDelayAndControlAndModuleGet(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				((not (self.oclIsKindOf(Delay))) and (not (self.oclIsKindOf(Control))) and (not (self.oclIsKindOf(ModuleGet)))) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_I_atomicbutDelayAndControlAndModuleGet";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_stop']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::Delay::D_NonAtomic12D_NonAtomic(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Alternates_D_NonAtomic";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_stop']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::If::I_nonReentrant12I_nonReentrant(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Alternates_I_nonReentrant";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_stop']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::If::I_startMeansEvaluate12I_startMeansEvaluate(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_I_startMeansEvaluate";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_doEvaluate']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::If::I_evaluatingResultsInTrueOrFalse122I_evaluatingResultsInTrueOrFalse(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_I_evaluatingResultsInTrueOrFalse";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_doEvaluate']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map i_trueOrFalse2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::If::I_trueExclusifFalse12I_trueExclusifFalse(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_I_trueExclusifFalse";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToFalse']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToTrue']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::If::I_startInternalofThen12I_startInternalofThen(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_I_startInternalofThen";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToTrue']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.block.instructions->first().oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::If::I_startInternalofElse102I_startInternalofElse(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.elseBlock <> null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_I_startInternalofElse";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToFalse']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.elseBlock.instructions->first().oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::If::I_startInternalofElseEmpty282I_startInternalofElseEmpty(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.elseBlock = null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_I_startInternalofElseEmpty";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map i_lastInstructionfromthenOrFalse2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_stop']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::If::I_stopInternalFirst342I_stopInternalFirst(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.elseBlock <> null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_I_stopInternalFirst";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map i_lastInstructionfromthenOrElse2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_stop']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::While::W_startOrFinishLoopMeansEvaluate192W_startOrFinishLoopMeansEvaluate(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_W_startOrFinishLoopMeansEvaluate";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map w_startOrEndLoop2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_doEvaluate']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::While::W_evaluatingResultsInTrueOrFalse122W_evaluatingResultsInTrueOrFalse(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_W_evaluatingResultsInTrueOrFalse";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_doEvaluate']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map w_trueOrFalse2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::While::W_trueExclusifFalse12W_trueExclusifFalse(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_W_trueExclusifFalse";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToFalse']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToTrue']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::While::W_startInternalFirst12W_startInternalFirst(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_W_startInternalFirst";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToTrue']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.block.instructions->first().oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::While::W_stopwhenEvaluatedFalse12W_stopwhenEvaluatedFalse(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_W_stopwhenEvaluatedFalse";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToFalse']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_stop']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::Repeat::R_startMeansEvaluate192R_startMeansEvaluate(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_R_startMeansEvaluate";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map r_startOrEndLoop2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_doEvaluate']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::Repeat::R_evaluatingResultsInTrueOrFalse122R_evaluatingResultsInTrueOrFalse(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_R_evaluatingResultsInTrueOrFalse";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_doEvaluate']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map r_trueOrFalse2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::Repeat::R_trueExclusifFalse12R_trueExclusifFalse(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_R_trueExclusifFalse";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToFalse']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToTrue']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::Repeat::R_startInternalFirst12R_startInternalFirst(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_R_startInternalFirst";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToTrue']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.block.instructions->first().oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::Repeat::R_stopwhenEvaluatedFalse12R_stopwhenEvaluatedFalse(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_R_stopwhenEvaluatedFalse";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_evaluatedToFalse']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_stop']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::ModuleGet::waitIfInVariableAssignment272waitIfInVariableAssignment(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.module.oclIsKindOf(ArduinoCommunicationModule)
			and
		self.module.oclAsType(ecore::EObject).eContainer().oclIsKindOf(VariableAssignment)
		) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_waitIfInVariableAssignment";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.module.oclAsType(ArduinoCommunicationModule).oclAsType(EObject))+'_receive']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.module.oclAsType(ecore::EObject).eContainer().oclAsType(VariableAssignment).oclAsType(EObject))+'_start']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::ModuleAssignment::sendAfterAssignement122sendAfterAssignement(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.module.oclIsKindOf(ArduinoCommunicationModule)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Alternates_sendAfterAssignement";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.module.oclAsType(ArduinoCommunicationModule).oclAsType(EObject))+'_send']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::BluetoothTransceiver::sendBeforeReceive982sendBeforeReceive(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				((self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().allInstances(ModuleAssignment)->select(ma|(ma).oclAsType(ModuleAssignment).module = self))->size() >0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_sendBeforeReceive";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_send']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.connectedTransceiver->first().oclAsType(EObject))+'_receive']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	

//Create an intermediate relation
	mapping inMM1::BluetoothTransceiver::intermediate_allReceiveTogether132allReceiveTogether(an1 : BluetoothTransceiver, an2 : BluetoothTransceiver, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allReceiveTogether'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Coincidence).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
		seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
		type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_receive']->first();
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_receive']->first();
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM1::BluetoothTransceiver::allReceiveTogether132allReceiveTogether()
			when { (self.connectedTransceiver->size() > 1) }
	{
		init{
			var sources : Sequence(BluetoothTransceiver) := self.connectedTransceiver->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_allReceiveTogether132allReceiveTogether(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		

//relation stuff		
	
		mapping inMM1::VariableAssignment::getDataIfModuleGetCom322getDataIfModuleGetCom(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.allInstances(ModuleGet)->select(mg | (mg).oclAsType(ModuleGet).module.oclIsKindOf(BluetoothTransceiver))->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Alternates_getDataIfModuleGetCom";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.allInstances(ModuleGet)->select(mg | (mg).oclAsType(ModuleGet).module.oclIsKindOf(BluetoothTransceiver))->asSequence()->first().oclAsType(ModuleGet).module.oclAsType(BluetoothTransceiver).oclAsType(EObject))+'_receive']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_start']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		





















mapping inMM1::Project::arduino2FeedBack() : FeedBack::ActionModel {
	    theFeedBackSpec := result;
		importStatements+= object FeedBack::ImportStatement{
			importURI := getModelPath(ccsl.objectsOfType(Clock)->asSequence()->first().oclAsType(EObject));
		}; 
		

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instruction.oclAsType(EClass)).oclAsType(Instruction)->map start2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Instruction.oclAsType(EClass)).oclAsType(Instruction)->map stop2MSE();




		

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Sketch.oclAsType(EClass)).oclAsType(Sketch)->map start2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Sketch.oclAsType(EClass)).oclAsType(Sketch)->map stop2MSE();




		

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Control.oclAsType(EClass)).oclAsType(Control)->map doEvaluate2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Control.oclAsType(EClass)).oclAsType(Control)->map evaluatedToTrue2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Control.oclAsType(EClass)).oclAsType(Control)->map evaluatedToFalse2MSE();

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Control.oclAsType(EClass)).oclAsType(Control)->map doEvaluate12ActionFeedBack();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Control.oclAsType(EClass)).oclAsType(Control)->map doEvaluate22ActionFeedBack();



		

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ArduinoCommunicationModule.oclAsType(EClass)).oclAsType(ArduinoCommunicationModule)->map send2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), ArduinoCommunicationModule.oclAsType(EClass)).oclAsType(ArduinoCommunicationModule)->map receive2MSE();




		

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), PushButton.oclAsType(EClass)).oclAsType(PushButton)->map toggleIt2MSE();




		





		





		





		





		





		





		





		





		





		





		







	}		


	 	mapping inMM1::Instruction::start2MSE() :FeedBack::ModelSpecificEvent 
			when { (not ((self).oclIsKindOf(ModuleGet))) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_start';
				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "execute")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_start')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::Instruction::stop2MSE() :FeedBack::ModelSpecificEvent 
			when { (not ((self).oclIsKindOf(ModuleGet))) }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_stop';
				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "finalize")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_stop')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::Sketch::start2MSE() :FeedBack::ModelSpecificEvent 
			when {  }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_start';
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_start')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::Sketch::stop2MSE() :FeedBack::ModelSpecificEvent 
			when {  }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_stop';
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_stop')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::Control::doEvaluate2MSE() :FeedBack::ModelSpecificEvent 
			when {  }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_doEvaluate';
				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "evaluate")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_doEvaluate')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::Control::evaluatedToTrue2MSE() :FeedBack::ModelSpecificEvent 
			when {  }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_evaluatedToTrue';
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_evaluatedToTrue')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::Control::evaluatedToFalse2MSE() :FeedBack::ModelSpecificEvent 
			when {  }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_evaluatedToFalse';
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_evaluatedToFalse')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::ArduinoCommunicationModule::send2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().allSubobjectsOfKind(ModuleAssignment)->select(ma|(ma).oclAsType(ModuleAssignment).module = self))->size() >0 }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_send';
				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "push")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_send')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::ArduinoCommunicationModule::receive2MSE() :FeedBack::ModelSpecificEvent 
			when { (self.oclAsType(ecore::EObject).eContainer().eContainer().eContainer().allSubobjectsOfKind(ModuleGet)->select(ma|(ma).oclAsType(ModuleGet).module = self))->size() >0 }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_receive';
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_receive')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::PushButton::toggleIt2MSE() :FeedBack::ModelSpecificEvent 
			when {  }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_toggleIt';
				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "toggle")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_toggleIt')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
			
		


		mapping inMM1::Control::doEvaluate12ActionFeedBack() :FeedBack::When 
			when {  }
		{
			action := object FeedBack::Force{
				kind := ForceKind::Presence;
				eventToBeForced := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_evaluatedToTrue')->first();
				
			};
			condition := object FeedBack::ActionResultCondition{
				operator := ComparisonOperator::equals;
				comparisonValue := true;
			};
			source := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_doEvaluate')->first();
			
			end{
				theFeedBackSpec.whenStatements += result;
			}
		}
		mapping inMM1::Control::doEvaluate22ActionFeedBack() :FeedBack::When 
			when {  }
		{
			action := object FeedBack::Force{
				kind := ForceKind::Presence;
				eventToBeForced := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_evaluatedToFalse')->first();
				
			};
			condition := object FeedBack::ActionResultCondition{
				operator := ComparisonOperator::equals;
				comparisonValue := false;
			};
			source := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_doEvaluate')->first();
			
			end{
				theFeedBackSpec.whenStatements += result;
			}
		}








